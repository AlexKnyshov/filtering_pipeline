'''
A script to concatenate sequence files
Relies on Biopython
'''

import sys
import glob
import logging
from Bio import AlignIO
from Bio.Alphabet import IUPAC, Gapped
from Bio import SeqIO


def extension_to_format(ext):
    '''
    A function to determine file format
    by extension
    '''
    if ext in ["fasta", "fas", "fa"]:
        return "fasta"
    elif ext in ["phylip", "phy"]:
        return "phylip-relaxed"
    elif ext in ["nexus", "nex"]:
        return "nexus"
    elif ext == "ss":
        return "ss"
    else:
        return "other"


def most_common(lst):
    '''
    A function to return the most common
    element of a list
    '''
    return max(set(lst), key=lst.count)


def ss_parser(filename):
    '''
    A function to parse SS file
    as generated by Winclada
    This allows concatenating molecular
    and categorical (morphological) data
    '''
    output = {}
    with open(filename, "rU") as fcon:
        next(fcon)# skip xread
        next(fcon)# skip taxa / char counters
        for line in fcon:
            line = line.strip()
            if line == ";":
                break
            output[line.split(" ")[0]] = line.split(" ")[-1]
    return output


def check_alphabet(filename, fformat):
    '''
    The function to determine the sequence alphabet.
    The code for this function is modified from
    https://stackoverflow.com/questions/41588725/estimate-
    alphabet-in-biopython-from-fasta-file/41596563#41596563
    '''
    alphabets = [IUPAC.ambiguous_dna, IUPAC.protein]
    first_record = list(SeqIO.parse(filename, fformat))[0]
    # check DNA first:
    leftover = set(str(first_record.seq).upper()) - \
               set(alphabets[0].letters) - set(["-", "?"])
    if len(leftover) == 0:
        detected = "DNA"
    else:
        leftover = set(str(first_record.seq).upper()) - \
                   set(alphabets[1].letters) - set(["-", "?", "X"])
        if len(leftover) == 0:
            detected = "Prot"
        else:
            logging.error("Unknown alphabet, problematic symbols: %s",
                          leftover)
            sys.exit()
    return detected


def sequence_recoder(original_seq):
    '''
    A function to recode nucleotide data
    into 0-1-2-3 format
    '''
    new_seq = str(original_seq) \
              .replace("a", "0") \
              .replace("t", "1") \
              .replace("g", "2") \
              .replace("c", "3") \
              .replace("w", "?") \
              .replace("n", "?") \
              .replace("r", "?") \
              .replace("y", "?") \
              .replace("s", "?") \
              .replace("m", "?")
    return new_seq


def generate_output(partnum, final_matrix, starts, ends, models, partlist):
    '''
    A function to write output files
    '''
    if partnum == "-tnt":
        with open("COMBINED.tnt", "w") as outf:
            print("xread", file=outf)
            print(str(ends[-1])+" "+str(len(final_matrix)), file=outf)
            tntm = []
            tnts = []
            tnte = []
            for part in range(0, len(models)):
                if part == 0:
                    tnts.append(starts[0]-1)
                    tnte.append(ends[0])
                    tntm.append(models[0])
                else:
                    if models[part] == models[part-1]:
                        tnte[-1] = ends[part]
                    else:
                        tnts.append(starts[part]-1)
                        tnte.append(ends[part])
                        tntm.append(models[part])
            for tntp in range(0, len(tntm)):
                if tntm[tntp] == "DNA":
                    print("&[dna]", file=outf)
                elif tntm[tntp] == "MULTI":
                    print("&[num]", file=outf)
                for rec in sorted(final_matrix.keys()):
                    print(str(rec)+" "+
                          str(final_matrix[rec][tnts[tntp]:tnte[tntp]]),
                          file=outf)
            print(";", file=outf)
            print("proc/;", file=outf)
    elif partnum == "-nex":
        with open("COMBINED.nex", "w") as outf:
            mline = ""
            for part in range(0, len(models)):
                if models[part] == "MULTI":
                    models[part] = "Standard"
                if part == 0:
                    mline += models[0]
                    mline += ":"
                    mline += str(starts[0])
                else:
                    if models[part] != models[part-1]:
                        mline += "-"
                        mline += str(ends[part-1])
                        mline += ","
                        mline += models[part]
                        mline += ":"
                        mline += str(starts[part])
            mline += "-"
            mline += str(ends[part])
            print("#nexus", file=outf)
            print("begin data;", file=outf)
            print("dimensions ntax=" + str(len(final_matrix)) +
                  " nchar=" + str(ends[-1]) + ";", file=outf)
            print("format datatype=mixed(" + mline +
                  ") interleave=yes  GAP = - MISSING = ?;", file=outf)
            print("matrix", file=outf)
            for rec in sorted(final_matrix.keys()):
                print(str(rec)+"\t"+str(final_matrix[rec]), file=outf)
            print(";", file=outf)
            print("end;", file=outf)
            for part in range(0, len(models)):
                print("charset", models[part] + str(part) +
                      "=" + str(starts[part]) + "-" + str(ends[part]) +
                      ";", file=outf)
    elif partnum == "-nex2":
        with open("COMBINED.nex", "w") as outf:
            print("#nexus", file=outf)
            print("begin data;", file=outf)
            print("dimensions ntax=" + str(len(final_matrix)) +
                  " nchar=" + str(ends[-1]) + ";", file=outf)
            print("format datatype=STANDARD interleave=yes  " +
                  "GAP = - MISSING = ? SYMBOLS = \"  0 1 2 3 4 5\";", file=outf)
            print("matrix", file=outf)
            for rec in sorted(final_matrix.keys()):
                recoded_sequence = sequence_recoder(final_matrix[rec])
                print(str(rec) + "\t" + recoded_sequence, file=outf)
            print(";", file=outf)
            print("end;", file=outf)
    else:
        with open("COMBINED.phy", "w") as outf:
            print(str(len(final_matrix))+" "+str(ends[-1]), file=outf)
            for rec in sorted(final_matrix.keys()):
                print(str(rec)+" "+str(final_matrix[rec]), file=outf)
        with open("partitions.prt", "w") as outputfile:
            if partnum == "-12a":
                range12 = []
                range3 = []
            for part in range(0, len(models)):
                if partnum == "-3":
                    if models[part] == "DNA":
                        print(models[part]+", "+partlist[part]+
                              "-1="+str(starts[part])+"-"+
                              str(ends[part])+"\\3", file=outputfile)
                        print(models[part]+", "+partlist[part]+
                              "-2="+str(starts[part]+1)+"-"+
                              str(ends[part])+"\\3", file=outputfile)
                        print(models[part]+", "+partlist[part]+
                              "-3="+str(starts[part]+2)+"-"+
                              str(ends[part])+"\\3", file=outputfile)
                    else:
                        print(models[part]+", "+partlist[part]+
                              "="+str(starts[part])+"-"+
                              str(ends[part]), file=outputfile)
                elif partnum == "-12":
                    if models[part] == "DNA":
                        print(models[part]+", "+partlist[part]+"-12="+
                              str(starts[part])+"-"+str(ends[part])+
                              "\\3, "+str(starts[part]+1)+"-"+
                              str(ends[part])+"\\3", file=outputfile)
                        print(models[part]+", "+partlist[part]+"-3="+
                              str(starts[part]+2)+"-"+str(ends[part])+
                              "\\3", file=outputfile)
                    else:
                        print(models[part]+", "+partlist[part]+"="+
                              str(starts[part])+"-"+str(ends[part]),
                              file=outputfile)
                elif partnum == "-12a":
                    if models[part] == "DNA":
                        range12.append(str(starts[part])+"-"+
                                       str(ends[part])+"\\3")
                        range12.append(str(starts[part]+1)+"-"+
                                       str(ends[part])+"\\3")
                        range3.append(str(starts[part]+2)+"-"+
                                      str(ends[part])+"\\3")
                    else:
                        print("model", models[part],
                              "is not supported, opt -12a is only for DNA")
                        sys.exit()
                elif partnum == "-1":
                    print(models[part]+", "+partlist[part]+"="+
                          str(starts[part])+"-"+str(ends[part]),
                          file=outputfile)
            if partnum == "-12a":
                print("DNA, concat-12="+",".join(range12), file=outputfile)
                print("DNA, concat-3="+",".join(range3), file=outputfile)


def parse_and_concatenate(inputfolder, partnum):
    '''
    A function to parse input files
    '''
    files = sorted(glob.glob(inputfolder+"/*"))
    logging.info("concatenating...")
    final_matrix = {}
    start = 0
    end = 0
    models = []
    starts = []
    ends = []
    partlist = []
    for infile in files:
        length = 0
        #init missed list with all currently encountered seqnames
        missed = list(final_matrix.keys())
        model = ""
        filename = infile.split("/")[-1]
        extension = filename.split(".")[-1]
        fformat = extension_to_format(extension)
        if fformat == "ss":
            matrix = ss_parser(infile)
            length = len(matrix.values()[0])
            model = "MULTI"
            for rec in matrix:
                if rec not in final_matrix:
                    # add padding for the preceding length
                    # of the alignment
                    if len(ends) > 0:
                        final_matrix[rec] = "?"*ends[-1]
                    else:
                        final_matrix[rec] = ""
                #add sequence
                final_matrix[rec] += matrix[rec]
                #remove encountered seqname from missed
                if rec in missed:
                    missed.remove(rec)
        elif fformat == "other":
            # skip non sequence / ss files
            continue
        else:
            alph = check_alphabet(infile, fformat)
            if alph == "DNA":
                alignment = AlignIO.read(infile,
                                         fformat,
                                         alphabet = Gapped(IUPAC.ambiguous_dna))
                model = "DNA"
            elif alph == "Prot":
                alignment = AlignIO.read(infile,
                                         fformat,
                                         alphabet = Gapped(IUPAC.protein, '-'))
                model = "LG"
            length = alignment.get_alignment_length()
            for seq in alignment:
                if seq.id not in final_matrix:
                    # add padding for the preceding length
                    # of the alignment
                    if len(ends) > 0:
                        final_matrix[seq.id] = "?"*ends[-1]
                    else:
                        final_matrix[seq.id] = ""
                #add sequence
                final_matrix[seq.id] += str(seq.seq)
                #remove encountered seqname from missed
                if seq.id in missed:
                    missed.remove(seq.id)
        #for all non encountered seqnames add empty seqs
        if len(missed) > 0:
            for mname in missed:
                if mname in final_matrix:
                    final_matrix[mname] += "?"*length
                else:
                    final_matrix[mname] = ""
                    final_matrix[mname] += "?"*length
        end = start + length - 1
        models.append(model)
        starts.append(start+1)
        ends.append(end+1)
        partlist.append(filename)
        prog = "working on partition "+str(len(starts))+", "+ \
               str(filename)+": starts "+str(start+1)+ \
               ", ends "+str(end+1)
        sys.stdout.write(prog+"\r")
        sys.stdout.flush()
        start = end + 1
    print()
    generate_output(partnum, final_matrix, starts, ends, models, partlist)
    logging.info("Done")


def main():
    '''
    The main function
    '''
    logging.basicConfig(format='%(asctime)s | %(levelname)s: %(message)s',
                        level=logging.NOTSET)
    if len(sys.argv) >= 3:
        inputfolder = sys.argv[1]
        partnum = sys.argv[2]
        parse_and_concatenate(inputfolder, partnum)
    else:
        print("FORMAT: python concat.py [folder with fasta] " +
              "[split to codon positions: -3 (yes), -1 (no), " +
              "-12 (combine first two), -12a (combine first two " +
              "across all), -tnt, -nex, -nex2 (recode DNA as discrete)]")
        print("EXAMPLE: python concat.py ./fasta -1")
        print("output is written to COMBINED.phy, " +
              "partitions are written to partitions.prt")


if __name__ == "__main__":
    main()
